// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApiKey = `-- name: CreateApiKey :one
INSERT INTO "api_keys" ("project_id", "user_id", "value") VALUES ($1, $2, $3)  RETURNING id, created_at, updated_at, deleted_at, expires_at, project_id, user_id, value
`

type CreateApiKeyParams struct {
	ProjectID int64
	UserID    int64
	Value     string
}

func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (ApiKeys, error) {
	row := q.db.QueryRow(ctx, createApiKey, arg.ProjectID, arg.UserID, arg.Value)
	var i ApiKeys
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExpiresAt,
		&i.ProjectID,
		&i.UserID,
		&i.Value,
	)
	return i, err
}

type CreateApiKeysParams struct {
	ProjectID int64
	UserID    int64
	Value     string
}

const createBackup = `-- name: CreateBackup :one
INSERT INTO "backup" ("content_type", "filename","project_id", "user_id", "URL", "slug", "provider") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, created_at, updated_at, deleted_at, content_type, filename, project_id, user_id, "URL", slug, provider
`

type CreateBackupParams struct {
	ContentType string
	Filename    string
	ProjectID   int64
	UserID      int64
	URL         string
	Slug        string
	Provider    string
}

func (q *Queries) CreateBackup(ctx context.Context, arg CreateBackupParams) (Backup, error) {
	row := q.db.QueryRow(ctx, createBackup,
		arg.ContentType,
		arg.Filename,
		arg.ProjectID,
		arg.UserID,
		arg.URL,
		arg.Slug,
		arg.Provider,
	)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ContentType,
		&i.Filename,
		&i.ProjectID,
		&i.UserID,
		&i.URL,
		&i.Slug,
		&i.Provider,
	)
	return i, err
}

type CreateBackupsParams struct {
	ContentType string
	Filename    string
	ProjectID   int64
	UserID      int64
	URL         string
	Slug        string
	Provider    string
}

const createComment = `-- name: CreateComment :one
INSERT INTO "comment" ("key_id", "value_id", "user_id", "message") VALUES ($1, $2, $3, $4) RETURNING id, created_at, updated_at, deleted_at, key_id, value_id, user_id, message
`

type CreateCommentParams struct {
	KeyID   int64
	ValueID *int64
	UserID  int64
	Message string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.KeyID,
		arg.ValueID,
		arg.UserID,
		arg.Message,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.KeyID,
		&i.ValueID,
		&i.UserID,
		&i.Message,
	)
	return i, err
}

type CreateCommentsParams struct {
	KeyID   int64
	ValueID *int64
	UserID  int64
	Message string
}

const createKey = `-- name: CreateKey :one
INSERT INTO "key" ("project_id" , "name", "key_type") VALUES ($1, $2, $3) RETURNING id, created_at, updated_at, deleted_at, project_id, name, key_type
`

type CreateKeyParams struct {
	ProjectID int64
	Name      string
	KeyType   KeyType
}

func (q *Queries) CreateKey(ctx context.Context, arg CreateKeyParams) (Key, error) {
	row := q.db.QueryRow(ctx, createKey, arg.ProjectID, arg.Name, arg.KeyType)
	var i Key
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.KeyType,
	)
	return i, err
}

type CreateKeysParams struct {
	ProjectID int64
	Name      string
	KeyType   KeyType
}

const createLocale = `-- name: CreateLocale :one
INSERT INTO "locale" ("project_id" , "name", "lang", "country", "code") VALUES ($1, $2, $3, $4, $5) RETURNING id, created_at, updated_at, deleted_at, project_id, name, lang, country, code
`

type CreateLocaleParams struct {
	ProjectID int64
	Name      string
	Lang      string
	Country   string
	Code      string
}

func (q *Queries) CreateLocale(ctx context.Context, arg CreateLocaleParams) (Locale, error) {
	row := q.db.QueryRow(ctx, createLocale,
		arg.ProjectID,
		arg.Name,
		arg.Lang,
		arg.Country,
		arg.Code,
	)
	var i Locale
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.Lang,
		&i.Country,
		&i.Code,
	)
	return i, err
}

type CreateLocalesParams struct {
	ProjectID int64
	Name      string
	Lang      string
	Country   string
	Code      string
}

const createMedia = `-- name: CreateMedia :one
INSERT INTO "media" ( "project_id", "content_type", "filename","user_id", "URL", "original_name", "slug", "provider", "title", "description", "key_IDs")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, created_at, updated_at, deleted_at, content_type, filename, project_id, user_id, "URL", original_name, slug, title, description, "key_IDs", provider
`

type CreateMediaParams struct {
	ProjectID    int64
	ContentType  string
	Filename     string
	UserID       int64
	URL          string
	OriginalName string
	Slug         string
	Provider     string
	Title        string
	Description  string
	KeyIDs       []int64
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Media, error) {
	row := q.db.QueryRow(ctx, createMedia,
		arg.ProjectID,
		arg.ContentType,
		arg.Filename,
		arg.UserID,
		arg.URL,
		arg.OriginalName,
		arg.Slug,
		arg.Provider,
		arg.Title,
		arg.Description,
		arg.KeyIDs,
	)
	var i Media
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ContentType,
		&i.Filename,
		&i.ProjectID,
		&i.UserID,
		&i.URL,
		&i.OriginalName,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.KeyIDs,
		&i.Provider,
	)
	return i, err
}

type CreateMediasParams struct {
	ProjectID    int64
	ContentType  string
	Filename     string
	UserID       int64
	URL          string
	OriginalName string
	Slug         string
	Provider     string
	Title        string
	Description  string
	KeyIDs       []int64
}

const createProject = `-- name: CreateProject :one
INSERT INTO "project" ("name", "description") VALUES ($1, $2) RETURNING id, created_at, updated_at, deleted_at, name, description
`

type CreateProjectParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.Name, arg.Description)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const createProjectUser = `-- name: CreateProjectUser :one
INSERT INTO "project_user" ("project_id", "user_id") VALUES ($1, $2) RETURNING id, created_at, updated_at, deleted_at, project_id, user_id
`

type CreateProjectUserParams struct {
	ProjectID int64
	UserID    int64
}

func (q *Queries) CreateProjectUser(ctx context.Context, arg CreateProjectUserParams) (ProjectUser, error) {
	row := q.db.QueryRow(ctx, createProjectUser, arg.ProjectID, arg.UserID)
	var i ProjectUser
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.UserID,
	)
	return i, err
}

type CreateProjectUsersParams struct {
	ProjectID int64
	UserID    int64
}

type CreateProjectsParams struct {
	Name        string
	Description string
}

const createUpload = `-- name: CreateUpload :one
INSERT INTO "upload" (  "content_type", "filename","project_id", "user_id", "URL", "slug", "provider") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, created_at, updated_at, deleted_at, content_type, filename, project_id, user_id, "URL", slug, provider
`

type CreateUploadParams struct {
	ContentType string
	Filename    string
	ProjectID   int64
	UserID      int64
	URL         string
	Slug        string
	Provider    string
}

func (q *Queries) CreateUpload(ctx context.Context, arg CreateUploadParams) (Upload, error) {
	row := q.db.QueryRow(ctx, createUpload,
		arg.ContentType,
		arg.Filename,
		arg.ProjectID,
		arg.UserID,
		arg.URL,
		arg.Slug,
		arg.Provider,
	)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ContentType,
		&i.Filename,
		&i.ProjectID,
		&i.UserID,
		&i.URL,
		&i.Slug,
		&i.Provider,
	)
	return i, err
}

type CreateUploadsParams struct {
	ContentType string
	Filename    string
	ProjectID   int64
	UserID      int64
	URL         string
	Slug        string
	Provider    string
}

const createUser = `-- name: CreateUser :one
INSERT INTO "user" ("email", "password", "first_name", "last_name") VALUES ($1, $2, $3, $4) RETURNING id, created_at, updated_at, deleted_at, email, password, first_name, last_name
`

type CreateUserParams struct {
	Email     string
	Password  string
	FirstName string
	LastName  string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Password,
		arg.FirstName,
		arg.LastName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.Password,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

type CreateUsersParams struct {
	Email     string
	Password  string
	FirstName string
	LastName  string
}

const createValue = `-- name: CreateValue :one
INSERT INTO "value" ("project_id", "key_id", "locale_id", "locale_code", "value", "status", "has_comments") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, created_at, updated_at, deleted_at, project_id, key_id, locale_id, locale_code, value, has_comments, status
`

type CreateValueParams struct {
	ProjectID   int64
	KeyID       int64
	LocaleID    int64
	LocaleCode  string
	Value       ValueWithPlurals
	Status      ValueStatus
	HasComments bool
}

func (q *Queries) CreateValue(ctx context.Context, arg CreateValueParams) (Value, error) {
	row := q.db.QueryRow(ctx, createValue,
		arg.ProjectID,
		arg.KeyID,
		arg.LocaleID,
		arg.LocaleCode,
		arg.Value,
		arg.Status,
		arg.HasComments,
	)
	var i Value
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.KeyID,
		&i.LocaleID,
		&i.LocaleCode,
		&i.Value,
		&i.HasComments,
		&i.Status,
	)
	return i, err
}

const createValueVersion = `-- name: CreateValueVersion :one
INSERT INTO "value_version" ("value_id", "creator_id", "value") VALUES ($1, $2, $3) RETURNING id, created_at, updated_at, deleted_at, value_id, creator_id, value
`

type CreateValueVersionParams struct {
	ValueID   int64
	CreatorID int64
	Value     ValueWithPlurals
}

func (q *Queries) CreateValueVersion(ctx context.Context, arg CreateValueVersionParams) (ValueVersion, error) {
	row := q.db.QueryRow(ctx, createValueVersion, arg.ValueID, arg.CreatorID, arg.Value)
	var i ValueVersion
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ValueID,
		&i.CreatorID,
		&i.Value,
	)
	return i, err
}

type CreateValueVersionsParams struct {
	ValueID   int64
	CreatorID int64
	Value     ValueWithPlurals
}

type CreateValuesParams struct {
	ProjectID   int64
	KeyID       int64
	LocaleID    int64
	LocaleCode  string
	Value       ValueWithPlurals
	Status      ValueStatus
	HasComments bool
}

const deleteCommentByID = `-- name: DeleteCommentByID :one
UPDATE "comment" SET "deleted_at" = now() WHERE "id" = $1 AND "deleted_at" is NULL RETURNING id, created_at, updated_at, deleted_at, key_id, value_id, user_id, message
`

func (q *Queries) DeleteCommentByID(ctx context.Context, id int64) (Comment, error) {
	row := q.db.QueryRow(ctx, deleteCommentByID, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.KeyID,
		&i.ValueID,
		&i.UserID,
		&i.Message,
	)
	return i, err
}

const deleteComments = `-- name: DeleteComments :exec
DELETE FROM "comment" WHERE "key_id" = ANY($1::bigint[])
`

func (q *Queries) DeleteComments(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteComments, dollar_1)
	return err
}

const deleteCommentsByKeysValuesIDs = `-- name: DeleteCommentsByKeysValuesIDs :many
UPDATE "comment" SET "deleted_at" = now() WHERE "key_id" = ANY($1::bigint[]) AND "value_id" = ANY($2::bigint[]) AND "user_id" = $3 RETURNING id, created_at, updated_at, deleted_at, key_id, value_id, user_id, message
`

type DeleteCommentsByKeysValuesIDsParams struct {
	Column1 []int64
	Column2 []int64
	UserID  int64
}

func (q *Queries) DeleteCommentsByKeysValuesIDs(ctx context.Context, arg DeleteCommentsByKeysValuesIDsParams) ([]Comment, error) {
	rows, err := q.db.Query(ctx, deleteCommentsByKeysValuesIDs, arg.Column1, arg.Column2, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Comment{}
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.KeyID,
			&i.ValueID,
			&i.UserID,
			&i.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteKeyByID = `-- name: DeleteKeyByID :many
UPDATE "key" SET "deleted_at" = now() WHERE "id" = $1 RETURNING id, created_at, updated_at, deleted_at, project_id, name, key_type
`

func (q *Queries) DeleteKeyByID(ctx context.Context, id int64) ([]Key, error) {
	rows, err := q.db.Query(ctx, deleteKeyByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Key{}
	for rows.Next() {
		var i Key
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Name,
			&i.KeyType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteKeys = `-- name: DeleteKeys :exec
DELETE FROM "key" WHERE "project_id" = $1
`

func (q *Queries) DeleteKeys(ctx context.Context, projectID int64) error {
	_, err := q.db.Exec(ctx, deleteKeys, projectID)
	return err
}

const deleteKeysByProjectID = `-- name: DeleteKeysByProjectID :many
UPDATE "key" SET "deleted_at" = now() WHERE "project_id" = $1 RETURNING id, created_at, updated_at, deleted_at, project_id, name, key_type
`

func (q *Queries) DeleteKeysByProjectID(ctx context.Context, projectID int64) ([]Key, error) {
	rows, err := q.db.Query(ctx, deleteKeysByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Key{}
	for rows.Next() {
		var i Key
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Name,
			&i.KeyType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteLocaleByID = `-- name: DeleteLocaleByID :one
UPDATE "locale" SET "deleted_at" = now() WHERE "locale"."id" = $1 RETURNING id, created_at, updated_at, deleted_at, project_id, name, lang, country, code
`

func (q *Queries) DeleteLocaleByID(ctx context.Context, id int64) (Locale, error) {
	row := q.db.QueryRow(ctx, deleteLocaleByID, id)
	var i Locale
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.Lang,
		&i.Country,
		&i.Code,
	)
	return i, err
}

const deleteLocales = `-- name: DeleteLocales :exec
DELETE FROM "locale" WHERE "project_id" = $1
`

func (q *Queries) DeleteLocales(ctx context.Context, projectID int64) error {
	_, err := q.db.Exec(ctx, deleteLocales, projectID)
	return err
}

const deleteLocalesByProjectID = `-- name: DeleteLocalesByProjectID :exec
UPDATE "locale" SET "deleted_at" = now() WHERE "project_id" = $1 RETURNING id, created_at, updated_at, deleted_at, project_id, name, lang, country, code
`

func (q *Queries) DeleteLocalesByProjectID(ctx context.Context, projectID int64) error {
	_, err := q.db.Exec(ctx, deleteLocalesByProjectID, projectID)
	return err
}

const deleteProject = `-- name: DeleteProject :many
UPDATE "project" SET "deleted_at" = now() WHERE "id" = $1 RETURNING id, created_at, updated_at, deleted_at, name, description
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) ([]Project, error) {
	rows, err := q.db.Query(ctx, deleteProject, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteProjectUser = `-- name: DeleteProjectUser :exec
UPDATE "project_user" SET "deleted_at" = now() WHERE "project_id" = $1 AND "user_id" = $2 RETURNING id, created_at, updated_at, deleted_at, project_id, user_id
`

type DeleteProjectUserParams struct {
	ProjectID int64
	UserID    int64
}

func (q *Queries) DeleteProjectUser(ctx context.Context, arg DeleteProjectUserParams) error {
	_, err := q.db.Exec(ctx, deleteProjectUser, arg.ProjectID, arg.UserID)
	return err
}

const deleteUserProjects = `-- name: DeleteUserProjects :exec
DELETE FROM "project_user" WHERE "project_id" = $1 and "user_id" = $2
`

type DeleteUserProjectsParams struct {
	ProjectID int64
	UserID    int64
}

func (q *Queries) DeleteUserProjects(ctx context.Context, arg DeleteUserProjectsParams) error {
	_, err := q.db.Exec(ctx, deleteUserProjects, arg.ProjectID, arg.UserID)
	return err
}

const deleteValueVersions = `-- name: DeleteValueVersions :exec
DELETE FROM "value_version" WHERE "value_id" = ANY($1::bigint[])
`

func (q *Queries) DeleteValueVersions(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteValueVersions, dollar_1)
	return err
}

const deleteValueVersionsByValueID = `-- name: DeleteValueVersionsByValueID :exec
UPDATE "value_version" SET "deleted_at" = now() WHERE "value_id" = ANY($1::bigint[])
`

func (q *Queries) DeleteValueVersionsByValueID(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteValueVersionsByValueID, dollar_1)
	return err
}

const deleteValues = `-- name: DeleteValues :exec
DELETE FROM "value" WHERE "project_id" = $1
`

func (q *Queries) DeleteValues(ctx context.Context, projectID int64) error {
	_, err := q.db.Exec(ctx, deleteValues, projectID)
	return err
}

const deleteValuesByKeyID = `-- name: DeleteValuesByKeyID :many
UPDATE "value" SET "deleted_at" = now()
WHERE "key_id" = ANY($1::bigint[]) RETURNING id, created_at, updated_at, deleted_at, project_id, key_id, locale_id, locale_code, value, has_comments, status
`

func (q *Queries) DeleteValuesByKeyID(ctx context.Context, dollar_1 []int64) ([]Value, error) {
	rows, err := q.db.Query(ctx, deleteValuesByKeyID, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Value{}
	for rows.Next() {
		var i Value
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.KeyID,
			&i.LocaleID,
			&i.LocaleCode,
			&i.Value,
			&i.HasComments,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteValuesByLocaleID = `-- name: DeleteValuesByLocaleID :many
UPDATE "value" SET "deleted_at" = now() WHERE "locale_id" = $1 RETURNING id, created_at, updated_at, deleted_at, project_id, key_id, locale_id, locale_code, value, has_comments, status
`

func (q *Queries) DeleteValuesByLocaleID(ctx context.Context, localeID int64) ([]Value, error) {
	rows, err := q.db.Query(ctx, deleteValuesByLocaleID, localeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Value{}
	for rows.Next() {
		var i Value
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.KeyID,
			&i.LocaleID,
			&i.LocaleCode,
			&i.Value,
			&i.HasComments,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteValuesByProjectID = `-- name: DeleteValuesByProjectID :many
UPDATE "value" SET "deleted_at" = now() WHERE "project_id" = $1 RETURNING id, created_at, updated_at, deleted_at, project_id, key_id, locale_id, locale_code, value, has_comments, status
`

func (q *Queries) DeleteValuesByProjectID(ctx context.Context, projectID int64) ([]Value, error) {
	rows, err := q.db.Query(ctx, deleteValuesByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Value{}
	for rows.Next() {
		var i Value
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.KeyID,
			&i.LocaleID,
			&i.LocaleCode,
			&i.Value,
			&i.HasComments,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllValueVersions = `-- name: FindAllValueVersions :many
SELECT id, created_at, updated_at, deleted_at, value_id, creator_id, value FROM "value_version" WHERE "value_id" = ANY($1::bigint[])
`

func (q *Queries) FindAllValueVersions(ctx context.Context, dollar_1 []int64) ([]ValueVersion, error) {
	rows, err := q.db.Query(ctx, findAllValueVersions, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ValueVersion{}
	for rows.Next() {
		var i ValueVersion
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ValueID,
			&i.CreatorID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findBackups = `-- name: FindBackups :many
SELECT id, created_at, updated_at, deleted_at, content_type, filename, project_id, user_id, "URL", slug, provider FROM "backup" WHERE "project_id" = $1
`

func (q *Queries) FindBackups(ctx context.Context, projectID int64) ([]Backup, error) {
	rows, err := q.db.Query(ctx, findBackups, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ContentType,
			&i.Filename,
			&i.ProjectID,
			&i.UserID,
			&i.URL,
			&i.Slug,
			&i.Provider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCommentByID = `-- name: FindCommentByID :one
SELECT 
    comment.id, comment.created_at, comment.updated_at, comment.deleted_at, comment.key_id, comment.value_id, comment.user_id, comment.message,
    u.id, u.created_at, u.updated_at, u.deleted_at, u.email, u.password, u.first_name, u.last_name
FROM "comment"
LEFT JOIN "user" u ON u."id" = "comment"."user_id"
WHERE "comment"."id" = $1  AND "comment"."deleted_at" IS NULL
ORDER BY "comment"."id" DESC
`

type FindCommentByIDRow struct {
	ID        int64
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	KeyID     int64
	ValueID   *int64
	UserID    int64
	Message   string
	User      User
}

func (q *Queries) FindCommentByID(ctx context.Context, id int64) (FindCommentByIDRow, error) {
	row := q.db.QueryRow(ctx, findCommentByID, id)
	var i FindCommentByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.KeyID,
		&i.ValueID,
		&i.UserID,
		&i.Message,
		&i.User.ID,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.DeletedAt,
		&i.User.Email,
		&i.User.Password,
		&i.User.FirstName,
		&i.User.LastName,
	)
	return i, err
}

const findComments = `-- name: FindComments :many
SELECT 
    comment.id, comment.created_at, comment.updated_at, comment.deleted_at, comment.key_id, comment.value_id, comment.user_id, comment.message,
    u.id, u.created_at, u.updated_at, u.deleted_at, u.email, u.password, u.first_name, u.last_name
FROM "comment"
LEFT JOIN "user" u ON u."id" = "comment"."user_id"
WHERE "comment"."key_id" = $1 AND "comment"."deleted_at" IS NULL
ORDER BY "comment"."id" DESC
`

type FindCommentsRow struct {
	ID        int64
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	KeyID     int64
	ValueID   *int64
	UserID    int64
	Message   string
	User      User
}

func (q *Queries) FindComments(ctx context.Context, keyID int64) ([]FindCommentsRow, error) {
	rows, err := q.db.Query(ctx, findComments, keyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindCommentsRow{}
	for rows.Next() {
		var i FindCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.KeyID,
			&i.ValueID,
			&i.UserID,
			&i.Message,
			&i.User.ID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.Email,
			&i.User.Password,
			&i.User.FirstName,
			&i.User.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCommentsByKeysIDs = `-- name: FindCommentsByKeysIDs :many
SELECT id, created_at, updated_at, deleted_at, key_id, value_id, user_id, message FROM "comment" WHERE "key_id" = ANY($1::bigint[]) AND "deleted_at" IS NULL
`

func (q *Queries) FindCommentsByKeysIDs(ctx context.Context, dollar_1 []int64) ([]Comment, error) {
	rows, err := q.db.Query(ctx, findCommentsByKeysIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Comment{}
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.KeyID,
			&i.ValueID,
			&i.UserID,
			&i.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findKeys = `-- name: FindKeys :many
SELECT id, created_at, updated_at, deleted_at, project_id, name, key_type FROM "key" WHERE "project_id" = $1
`

func (q *Queries) FindKeys(ctx context.Context, projectID int64) ([]Key, error) {
	rows, err := q.db.Query(ctx, findKeys, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Key{}
	for rows.Next() {
		var i Key
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Name,
			&i.KeyType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findKeysByProjectID = `-- name: FindKeysByProjectID :many
SELECT
    key.id, key.created_at, key.updated_at, key.deleted_at, key.project_id, key.name, key.key_type,
    value.id, value.created_at, value.updated_at, value.deleted_at, value.project_id, value.key_id, value.locale_id, value.locale_code, value.value, value.has_comments, value.status
FROM "key"
         LEFT JOIN "value" ON value.key_id = key.id
WHERE key.project_id = $1 AND key.deleted_at IS NULL AND value.deleted_at IS NULL
ORDER BY key.id DESC, value.locale_id ASC
`

type FindKeysByProjectIDRow struct {
	Key   Key
	Value Value
}

func (q *Queries) FindKeysByProjectID(ctx context.Context, projectID int64) ([]FindKeysByProjectIDRow, error) {
	rows, err := q.db.Query(ctx, findKeysByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindKeysByProjectIDRow{}
	for rows.Next() {
		var i FindKeysByProjectIDRow
		if err := rows.Scan(
			&i.Key.ID,
			&i.Key.CreatedAt,
			&i.Key.UpdatedAt,
			&i.Key.DeletedAt,
			&i.Key.ProjectID,
			&i.Key.Name,
			&i.Key.KeyType,
			&i.Value.ID,
			&i.Value.CreatedAt,
			&i.Value.UpdatedAt,
			&i.Value.DeletedAt,
			&i.Value.ProjectID,
			&i.Value.KeyID,
			&i.Value.LocaleID,
			&i.Value.LocaleCode,
			&i.Value.Value,
			&i.Value.HasComments,
			&i.Value.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLocales = `-- name: FindLocales :many
SELECT id, created_at, updated_at, deleted_at, project_id, name, lang, country, code FROM "locale" WHERE "project_id" = $1
`

func (q *Queries) FindLocales(ctx context.Context, projectID int64) ([]Locale, error) {
	rows, err := q.db.Query(ctx, findLocales, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Locale{}
	for rows.Next() {
		var i Locale
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Name,
			&i.Lang,
			&i.Country,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLocalesByProjectID = `-- name: FindLocalesByProjectID :many
SELECT id, created_at, updated_at, deleted_at, project_id, name, lang, country, code FROM "locale" WHERE "project_id" = $1 AND "deleted_at" IS NULL ORDER BY "id" ASC
`

func (q *Queries) FindLocalesByProjectID(ctx context.Context, projectID int64) ([]Locale, error) {
	rows, err := q.db.Query(ctx, findLocalesByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Locale{}
	for rows.Next() {
		var i Locale
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.Name,
			&i.Lang,
			&i.Country,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProjectsByUserID = `-- name: FindProjectsByUserID :many
SELECT 
    project.id, project.created_at, project.updated_at, project.deleted_at, project.name, project.description,  
    locale.id, locale.created_at, locale.updated_at, locale.deleted_at, locale.project_id, locale.name, locale.lang, locale.country, locale.code
FROM "project" 
INNER JOIN "project_user"   ON "project_user"."project_id" = "project"."id" AND "project_user"."deleted_at" IS NULL
LEFT JOIN "locale"          ON "locale"."project_id" = "project"."id" AND "locale"."deleted_at" IS NULL
WHERE "project_user"."user_id" = $1 AND "project"."deleted_at" IS NULL
`

type FindProjectsByUserIDRow struct {
	ID          int64
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	Name        string
	Description string
	Locale      Locale
}

func (q *Queries) FindProjectsByUserID(ctx context.Context, userID int64) ([]FindProjectsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, findProjectsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindProjectsByUserIDRow{}
	for rows.Next() {
		var i FindProjectsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Description,
			&i.Locale.ID,
			&i.Locale.CreatedAt,
			&i.Locale.UpdatedAt,
			&i.Locale.DeletedAt,
			&i.Locale.ProjectID,
			&i.Locale.Name,
			&i.Locale.Lang,
			&i.Locale.Country,
			&i.Locale.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUpload = `-- name: FindUpload :one
SELECT id, created_at, updated_at, deleted_at, content_type, filename, project_id, user_id, "URL", slug, provider FROM "upload" WHERE "id" = $1
`

func (q *Queries) FindUpload(ctx context.Context, id int64) (Upload, error) {
	row := q.db.QueryRow(ctx, findUpload, id)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ContentType,
		&i.Filename,
		&i.ProjectID,
		&i.UserID,
		&i.URL,
		&i.Slug,
		&i.Provider,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, created_at, updated_at, deleted_at, email, password, first_name, last_name FROM "user" WHERE "email" = $1 LIMIT 1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.Password,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const findUserProjects = `-- name: FindUserProjects :many
SELECT id, created_at, updated_at, deleted_at, project_id, user_id FROM "project_user" WHERE "project_id" = $1 AND "user_id" = $2
`

type FindUserProjectsParams struct {
	ProjectID int64
	UserID    int64
}

func (q *Queries) FindUserProjects(ctx context.Context, arg FindUserProjectsParams) ([]ProjectUser, error) {
	rows, err := q.db.Query(ctx, findUserProjects, arg.ProjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectUser{}
	for rows.Next() {
		var i ProjectUser
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findValueVersions = `-- name: FindValueVersions :many
SELECT value_version.id, value_version.created_at, value_version.updated_at, value_version.deleted_at, value_version.value_id, value_version.creator_id, value_version.value,
    u.id, u.created_at, u.updated_at, u.deleted_at, u.email, u.password, u.first_name, u.last_name
FROM "value_version"
LEFT JOIN "user" u ON u."id" = "value_version"."creator_id"
WHERE "value_id" = $1 AND "value_version"."deleted_at" IS NULL ORDER BY "value_version"."id" DESC
`

type FindValueVersionsRow struct {
	ID        int64
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	ValueID   int64
	CreatorID int64
	Value     ValueWithPlurals
	User      User
}

func (q *Queries) FindValueVersions(ctx context.Context, valueID int64) ([]FindValueVersionsRow, error) {
	rows, err := q.db.Query(ctx, findValueVersions, valueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindValueVersionsRow{}
	for rows.Next() {
		var i FindValueVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ValueID,
			&i.CreatorID,
			&i.Value,
			&i.User.ID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.Email,
			&i.User.Password,
			&i.User.FirstName,
			&i.User.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findValues = `-- name: FindValues :many
SELECT id, created_at, updated_at, deleted_at, project_id, key_id, locale_id, locale_code, value, has_comments, status FROM "value" WHERE "project_id" = $1
`

func (q *Queries) FindValues(ctx context.Context, projectID int64) ([]Value, error) {
	rows, err := q.db.Query(ctx, findValues, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Value{}
	for rows.Next() {
		var i Value
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.KeyID,
			&i.LocaleID,
			&i.LocaleCode,
			&i.Value,
			&i.HasComments,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findValuesByKeyID = `-- name: FindValuesByKeyID :many
SELECT id, created_at, updated_at, deleted_at, project_id, key_id, locale_id, locale_code, value, has_comments, status FROM "value" WHERE "key_id" = $1 AND "deleted_at" IS NULL
`

func (q *Queries) FindValuesByKeyID(ctx context.Context, keyID int64) ([]Value, error) {
	rows, err := q.db.Query(ctx, findValuesByKeyID, keyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Value{}
	for rows.Next() {
		var i Value
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProjectID,
			&i.KeyID,
			&i.LocaleID,
			&i.LocaleCode,
			&i.Value,
			&i.HasComments,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackupByID = `-- name: GetBackupByID :one
SELECT id, created_at, updated_at, deleted_at, content_type, filename, project_id, user_id, "URL", slug, provider FROM "backup" WHERE "id" = $1
`

func (q *Queries) GetBackupByID(ctx context.Context, id int64) (Backup, error) {
	row := q.db.QueryRow(ctx, getBackupByID, id)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ContentType,
		&i.Filename,
		&i.ProjectID,
		&i.UserID,
		&i.URL,
		&i.Slug,
		&i.Provider,
	)
	return i, err
}

const getMediaByProjectID = `-- name: GetMediaByProjectID :many
SELECT id, created_at, updated_at, deleted_at, content_type, filename, project_id, user_id, "URL", original_name, slug, title, description, "key_IDs", provider FROM "media" WHERE "project_id" = $1
`

func (q *Queries) GetMediaByProjectID(ctx context.Context, projectID int64) ([]Media, error) {
	rows, err := q.db.Query(ctx, getMediaByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Media{}
	for rows.Next() {
		var i Media
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ContentType,
			&i.Filename,
			&i.ProjectID,
			&i.UserID,
			&i.URL,
			&i.OriginalName,
			&i.Slug,
			&i.Title,
			&i.Description,
			&i.KeyIDs,
			&i.Provider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUploadByIDs = `-- name: GetUploadByIDs :many
SELECT id, created_at, updated_at, deleted_at, content_type, filename, project_id, user_id, "URL", slug, provider FROM "upload"
    WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetUploadByIDs(ctx context.Context, dollar_1 []int64) ([]Upload, error) {
	rows, err := q.db.Query(ctx, getUploadByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Upload{}
	for rows.Next() {
		var i Upload
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ContentType,
			&i.Filename,
			&i.ProjectID,
			&i.UserID,
			&i.URL,
			&i.Slug,
			&i.Provider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type RestoreCommentsParams struct {
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	KeyID     int64
	ValueID   *int64
	UserID    int64
	Message   string
}

type RestoreKeysParams struct {
	ID        int64
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	ProjectID int64
	Name      string
	KeyType   KeyType
}

type RestoreLocalesParams struct {
	ID        int64
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	ProjectID int64
	Name      string
	Lang      string
	Country   string
	Code      string
}

type RestoreProjectUsersParams struct {
	ID        int64
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	ProjectID int64
	UserID    int64
}

type RestoreValueVersionsParams struct {
	ID        int64
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
	ValueID   int64
	CreatorID int64
	Value     ValueWithPlurals
}

type RestoreValuesParams struct {
	ID          int64
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	ProjectID   int64
	KeyID       int64
	LocaleID    int64
	LocaleCode  string
	Value       ValueWithPlurals
	Status      ValueStatus
	HasComments bool
}

const testModeCallCreateAllTriggers = `-- name: TestModeCallCreateAllTriggers :exec
CALL test_mode_create_triggers()
`

func (q *Queries) TestModeCallCreateAllTriggers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, testModeCallCreateAllTriggers)
	return err
}

const testModeCallResetAutoincrement = `-- name: TestModeCallResetAutoincrement :exec
CALL test_mode_create_reset_autoincrement_function()
`

func (q *Queries) TestModeCallResetAutoincrement(ctx context.Context) error {
	_, err := q.db.Exec(ctx, testModeCallResetAutoincrement)
	return err
}

const testModeCreateResetAutomincrementFunction = `-- name: TestModeCreateResetAutomincrementFunction :exec
CREATE OR REPLACE PROCEDURE test_mode_create_reset_autoincrement_function()
language plpgsql
AS $$
DECLARE
    tables CURSOR FOR
        SELECT c.relname as tablename
		FROM pg_class c 
		LEFT JOIN pg_namespace n ON n.oid = c.relnamespace 
		WHERE c.relkind = 'r' and n.nspname = 'public'  and c.relname != 'schema_migrations'
		GROUP BY c.relname;
    maxID bigint;
BEGIN
    FOR table_record IN tables LOOP
        EXECUTE 'SELECT max(id) FROM "' || table_record.tablename || '"' INTO maxID;
        PERFORM SETVAL(pg_get_serial_sequence(table_record.tablename, 'id'), maxID);
    END LOOP;
END
$$
`

func (q *Queries) TestModeCreateResetAutomincrementFunction(ctx context.Context) error {
	_, err := q.db.Exec(ctx, testModeCreateResetAutomincrementFunction)
	return err
}

const testModeCreateSetTimeTriggerFunction = `-- name: TestModeCreateSetTimeTriggerFunction :exec
CREATE OR REPLACE FUNCTION test_mode_set_time() 
RETURNS trigger 
LANGUAGE plpgsql AS $$
BEGIN
  new.created_at = '2023-04-01 12:30:00'::TIMESTAMP;
  new.updated_at = new.created_at;
  RETURN new;
END;
$$
`

func (q *Queries) TestModeCreateSetTimeTriggerFunction(ctx context.Context) error {
	_, err := q.db.Exec(ctx, testModeCreateSetTimeTriggerFunction)
	return err
}

const testModeCreateTriggerOnAllTablesFunction = `-- name: TestModeCreateTriggerOnAllTablesFunction :exec
CREATE OR REPLACE PROCEDURE test_mode_create_triggers()
LANGUAGE plpgsql AS $$
DECLARE
  _sql VARCHAR;
BEGIN
  FOR _sql IN SELECT CONCAT (
      'create trigger tg_',
      table_name,
      '_before_insert_or_update before insert or update on ',
      QUOTE_IDENT(table_name),
      ' for each row execute procedure test_mode_set_time ();'
    )
    FROM
      information_schema.tables
    WHERE  
      table_schema NOT IN ('pg_catalog', 'information_schema') AND    
      table_schema NOT LIKE 'pg_toast%' AND
      table_name NOT IN ('schema_migrations')
  LOOP
    EXECUTE _sql;
  END LOOP;
END;
$$
`

func (q *Queries) TestModeCreateTriggerOnAllTablesFunction(ctx context.Context) error {
	_, err := q.db.Exec(ctx, testModeCreateTriggerOnAllTablesFunction)
	return err
}

const updateComment = `-- name: UpdateComment :one
UPDATE "comment" SET "message" = $1 WHERE "id" = $2 AND "deleted_at" is NULL RETURNING id, created_at, updated_at, deleted_at, key_id, value_id, user_id, message
`

type UpdateCommentParams struct {
	Message string
	ID      int64
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, updateComment, arg.Message, arg.ID)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.KeyID,
		&i.ValueID,
		&i.UserID,
		&i.Message,
	)
	return i, err
}

const updateCommentInValue = `-- name: UpdateCommentInValue :one
UPDATE "value" SET
    "has_comments"  = coalesce($1, has_comments)
WHERE "id" = $2 AND deleted_at is NULL RETURNING id, created_at, updated_at, deleted_at, project_id, key_id, locale_id, locale_code, value, has_comments, status
`

type UpdateCommentInValueParams struct {
	HasComments *bool
	ID          int64
}

func (q *Queries) UpdateCommentInValue(ctx context.Context, arg UpdateCommentInValueParams) (Value, error) {
	row := q.db.QueryRow(ctx, updateCommentInValue, arg.HasComments, arg.ID)
	var i Value
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.KeyID,
		&i.LocaleID,
		&i.LocaleCode,
		&i.Value,
		&i.HasComments,
		&i.Status,
	)
	return i, err
}

const updateKey = `-- name: UpdateKey :one
UPDATE "key" SET
    "name"      = coalesce($1, name),
    "key_type"  = $2
WHERE "id" = $3 AND deleted_at is NULL RETURNING id, created_at, updated_at, deleted_at, project_id, name, key_type
`

type UpdateKeyParams struct {
	Name    *string
	KeyType KeyType
	ID      int64
}

func (q *Queries) UpdateKey(ctx context.Context, arg UpdateKeyParams) (Key, error) {
	row := q.db.QueryRow(ctx, updateKey, arg.Name, arg.KeyType, arg.ID)
	var i Key
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.KeyType,
	)
	return i, err
}

const updateLocale = `-- name: UpdateLocale :one
UPDATE "locale" SET
    "name"      = coalesce($1, name),
    "lang"      = coalesce($2, lang),
    "country"   = coalesce($3, country),
    "code"      = coalesce($4, code)
WHERE "locale"."id" = $5 AND deleted_at is NULL RETURNING id, created_at, updated_at, deleted_at, project_id, name, lang, country, code
`

type UpdateLocaleParams struct {
	Name    *string
	Lang    *string
	Country *string
	Code    *string
	ID      int64
}

func (q *Queries) UpdateLocale(ctx context.Context, arg UpdateLocaleParams) (Locale, error) {
	row := q.db.QueryRow(ctx, updateLocale,
		arg.Name,
		arg.Lang,
		arg.Country,
		arg.Code,
		arg.ID,
	)
	var i Locale
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.Name,
		&i.Lang,
		&i.Country,
		&i.Code,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE "project" SET
     "name"        = coalesce($1, name),
     "description" = coalesce($2, description)
WHERE "id" = $3 AND deleted_at is NULL RETURNING id, created_at, updated_at, deleted_at, name, description
`

type UpdateProjectParams struct {
	Name        *string
	Description *string
	ID          int64
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject, arg.Name, arg.Description, arg.ID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const updateValue = `-- name: UpdateValue :one
UPDATE "value" SET 
    "value"         = coalesce($1, value),
    "status"        = coalesce($2, status),
    "has_comments"  = coalesce($3, has_comments)
WHERE "id" = $4 AND deleted_at is NULL RETURNING id, created_at, updated_at, deleted_at, project_id, key_id, locale_id, locale_code, value, has_comments, status
`

type UpdateValueParams struct {
	Value       ValueWithPlurals
	Status      NullValueStatus
	HasComments *bool
	ID          int64
}

func (q *Queries) UpdateValue(ctx context.Context, arg UpdateValueParams) (Value, error) {
	row := q.db.QueryRow(ctx, updateValue,
		arg.Value,
		arg.Status,
		arg.HasComments,
		arg.ID,
	)
	var i Value
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProjectID,
		&i.KeyID,
		&i.LocaleID,
		&i.LocaleCode,
		&i.Value,
		&i.HasComments,
		&i.Status,
	)
	return i, err
}
