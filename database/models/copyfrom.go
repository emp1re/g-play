// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: copyfrom.go

package models

import (
	"context"
)

// iteratorForCreateApiKeys implements pgx.CopyFromSource.
type iteratorForCreateApiKeys struct {
	rows                 []CreateApiKeysParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateApiKeys) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateApiKeys) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ProjectID,
		r.rows[0].UserID,
		r.rows[0].Value,
	}, nil
}

func (r iteratorForCreateApiKeys) Err() error {
	return nil
}

func (q *Queries) CreateApiKeys(ctx context.Context, arg []CreateApiKeysParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"api_keys"}, []string{"project_id", "user_id", "value"}, &iteratorForCreateApiKeys{rows: arg})
}

// iteratorForCreateBackups implements pgx.CopyFromSource.
type iteratorForCreateBackups struct {
	rows                 []CreateBackupsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateBackups) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateBackups) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ContentType,
		r.rows[0].Filename,
		r.rows[0].ProjectID,
		r.rows[0].UserID,
		r.rows[0].URL,
		r.rows[0].Slug,
		r.rows[0].Provider,
	}, nil
}

func (r iteratorForCreateBackups) Err() error {
	return nil
}

func (q *Queries) CreateBackups(ctx context.Context, arg []CreateBackupsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"backup"}, []string{"content_type", "filename", "project_id", "user_id", "URL", "slug", "provider"}, &iteratorForCreateBackups{rows: arg})
}

// iteratorForCreateComments implements pgx.CopyFromSource.
type iteratorForCreateComments struct {
	rows                 []CreateCommentsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateComments) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateComments) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].KeyID,
		r.rows[0].ValueID,
		r.rows[0].UserID,
		r.rows[0].Message,
	}, nil
}

func (r iteratorForCreateComments) Err() error {
	return nil
}

func (q *Queries) CreateComments(ctx context.Context, arg []CreateCommentsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"comment"}, []string{"key_id", "value_id", "user_id", "message"}, &iteratorForCreateComments{rows: arg})
}

// iteratorForCreateKeys implements pgx.CopyFromSource.
type iteratorForCreateKeys struct {
	rows                 []CreateKeysParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateKeys) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateKeys) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ProjectID,
		r.rows[0].Name,
		r.rows[0].KeyType,
	}, nil
}

func (r iteratorForCreateKeys) Err() error {
	return nil
}

func (q *Queries) CreateKeys(ctx context.Context, arg []CreateKeysParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"key"}, []string{"project_id", "name", "key_type"}, &iteratorForCreateKeys{rows: arg})
}

// iteratorForCreateLocales implements pgx.CopyFromSource.
type iteratorForCreateLocales struct {
	rows                 []CreateLocalesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateLocales) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateLocales) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ProjectID,
		r.rows[0].Name,
		r.rows[0].Lang,
		r.rows[0].Country,
		r.rows[0].Code,
	}, nil
}

func (r iteratorForCreateLocales) Err() error {
	return nil
}

func (q *Queries) CreateLocales(ctx context.Context, arg []CreateLocalesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"locale"}, []string{"project_id", "name", "lang", "country", "code"}, &iteratorForCreateLocales{rows: arg})
}

// iteratorForCreateMedias implements pgx.CopyFromSource.
type iteratorForCreateMedias struct {
	rows                 []CreateMediasParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateMedias) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateMedias) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ProjectID,
		r.rows[0].ContentType,
		r.rows[0].Filename,
		r.rows[0].UserID,
		r.rows[0].URL,
		r.rows[0].OriginalName,
		r.rows[0].Slug,
		r.rows[0].Provider,
		r.rows[0].Title,
		r.rows[0].Description,
		r.rows[0].KeyIDs,
	}, nil
}

func (r iteratorForCreateMedias) Err() error {
	return nil
}

func (q *Queries) CreateMedias(ctx context.Context, arg []CreateMediasParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"media"}, []string{"project_id", "content_type", "filename", "user_id", "URL", "original_name", "slug", "provider", "title", "description", "key_IDs"}, &iteratorForCreateMedias{rows: arg})
}

// iteratorForCreateProjectUsers implements pgx.CopyFromSource.
type iteratorForCreateProjectUsers struct {
	rows                 []CreateProjectUsersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateProjectUsers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateProjectUsers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ProjectID,
		r.rows[0].UserID,
	}, nil
}

func (r iteratorForCreateProjectUsers) Err() error {
	return nil
}

func (q *Queries) CreateProjectUsers(ctx context.Context, arg []CreateProjectUsersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"project_user"}, []string{"project_id", "user_id"}, &iteratorForCreateProjectUsers{rows: arg})
}

// iteratorForCreateProjects implements pgx.CopyFromSource.
type iteratorForCreateProjects struct {
	rows                 []CreateProjectsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateProjects) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateProjects) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Name,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForCreateProjects) Err() error {
	return nil
}

func (q *Queries) CreateProjects(ctx context.Context, arg []CreateProjectsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"project"}, []string{"name", "description"}, &iteratorForCreateProjects{rows: arg})
}

// iteratorForCreateUploads implements pgx.CopyFromSource.
type iteratorForCreateUploads struct {
	rows                 []CreateUploadsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateUploads) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateUploads) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ContentType,
		r.rows[0].Filename,
		r.rows[0].ProjectID,
		r.rows[0].UserID,
		r.rows[0].URL,
		r.rows[0].Slug,
		r.rows[0].Provider,
	}, nil
}

func (r iteratorForCreateUploads) Err() error {
	return nil
}

func (q *Queries) CreateUploads(ctx context.Context, arg []CreateUploadsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"upload"}, []string{"content_type", "filename", "project_id", "user_id", "URL", "slug", "provider"}, &iteratorForCreateUploads{rows: arg})
}

// iteratorForCreateUsers implements pgx.CopyFromSource.
type iteratorForCreateUsers struct {
	rows                 []CreateUsersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateUsers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateUsers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Email,
		r.rows[0].Password,
		r.rows[0].FirstName,
		r.rows[0].LastName,
	}, nil
}

func (r iteratorForCreateUsers) Err() error {
	return nil
}

func (q *Queries) CreateUsers(ctx context.Context, arg []CreateUsersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"user"}, []string{"email", "password", "first_name", "last_name"}, &iteratorForCreateUsers{rows: arg})
}

// iteratorForCreateValueVersions implements pgx.CopyFromSource.
type iteratorForCreateValueVersions struct {
	rows                 []CreateValueVersionsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateValueVersions) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateValueVersions) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ValueID,
		r.rows[0].CreatorID,
		r.rows[0].Value,
	}, nil
}

func (r iteratorForCreateValueVersions) Err() error {
	return nil
}

func (q *Queries) CreateValueVersions(ctx context.Context, arg []CreateValueVersionsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"value_version"}, []string{"value_id", "creator_id", "value"}, &iteratorForCreateValueVersions{rows: arg})
}

// iteratorForCreateValues implements pgx.CopyFromSource.
type iteratorForCreateValues struct {
	rows                 []CreateValuesParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateValues) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateValues) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ProjectID,
		r.rows[0].KeyID,
		r.rows[0].LocaleID,
		r.rows[0].LocaleCode,
		r.rows[0].Value,
		r.rows[0].Status,
		r.rows[0].HasComments,
	}, nil
}

func (r iteratorForCreateValues) Err() error {
	return nil
}

func (q *Queries) CreateValues(ctx context.Context, arg []CreateValuesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"value"}, []string{"project_id", "key_id", "locale_id", "locale_code", "value", "status", "has_comments"}, &iteratorForCreateValues{rows: arg})
}

// iteratorForRestoreComments implements pgx.CopyFromSource.
type iteratorForRestoreComments struct {
	rows                 []RestoreCommentsParams
	skippedFirstNextCall bool
}

func (r *iteratorForRestoreComments) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForRestoreComments) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].DeletedAt,
		r.rows[0].KeyID,
		r.rows[0].ValueID,
		r.rows[0].UserID,
		r.rows[0].Message,
	}, nil
}

func (r iteratorForRestoreComments) Err() error {
	return nil
}

func (q *Queries) RestoreComments(ctx context.Context, arg []RestoreCommentsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"comment"}, []string{"created_at", "updated_at", "deleted_at", "key_id", "value_id", "user_id", "message"}, &iteratorForRestoreComments{rows: arg})
}

// iteratorForRestoreKeys implements pgx.CopyFromSource.
type iteratorForRestoreKeys struct {
	rows                 []RestoreKeysParams
	skippedFirstNextCall bool
}

func (r *iteratorForRestoreKeys) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForRestoreKeys) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].DeletedAt,
		r.rows[0].ProjectID,
		r.rows[0].Name,
		r.rows[0].KeyType,
	}, nil
}

func (r iteratorForRestoreKeys) Err() error {
	return nil
}

func (q *Queries) RestoreKeys(ctx context.Context, arg []RestoreKeysParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"key"}, []string{"id", "created_at", "updated_at", "deleted_at", "project_id", "name", "key_type"}, &iteratorForRestoreKeys{rows: arg})
}

// iteratorForRestoreLocales implements pgx.CopyFromSource.
type iteratorForRestoreLocales struct {
	rows                 []RestoreLocalesParams
	skippedFirstNextCall bool
}

func (r *iteratorForRestoreLocales) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForRestoreLocales) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].DeletedAt,
		r.rows[0].ProjectID,
		r.rows[0].Name,
		r.rows[0].Lang,
		r.rows[0].Country,
		r.rows[0].Code,
	}, nil
}

func (r iteratorForRestoreLocales) Err() error {
	return nil
}

func (q *Queries) RestoreLocales(ctx context.Context, arg []RestoreLocalesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"locale"}, []string{"id", "created_at", "updated_at", "deleted_at", "project_id", "name", "lang", "country", "code"}, &iteratorForRestoreLocales{rows: arg})
}

// iteratorForRestoreProjectUsers implements pgx.CopyFromSource.
type iteratorForRestoreProjectUsers struct {
	rows                 []RestoreProjectUsersParams
	skippedFirstNextCall bool
}

func (r *iteratorForRestoreProjectUsers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForRestoreProjectUsers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].DeletedAt,
		r.rows[0].ProjectID,
		r.rows[0].UserID,
	}, nil
}

func (r iteratorForRestoreProjectUsers) Err() error {
	return nil
}

func (q *Queries) RestoreProjectUsers(ctx context.Context, arg []RestoreProjectUsersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"project_user"}, []string{"id", "created_at", "updated_at", "deleted_at", "project_id", "user_id"}, &iteratorForRestoreProjectUsers{rows: arg})
}

// iteratorForRestoreValueVersions implements pgx.CopyFromSource.
type iteratorForRestoreValueVersions struct {
	rows                 []RestoreValueVersionsParams
	skippedFirstNextCall bool
}

func (r *iteratorForRestoreValueVersions) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForRestoreValueVersions) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].DeletedAt,
		r.rows[0].ValueID,
		r.rows[0].CreatorID,
		r.rows[0].Value,
	}, nil
}

func (r iteratorForRestoreValueVersions) Err() error {
	return nil
}

func (q *Queries) RestoreValueVersions(ctx context.Context, arg []RestoreValueVersionsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"value_version"}, []string{"id", "created_at", "updated_at", "deleted_at", "value_id", "creator_id", "value"}, &iteratorForRestoreValueVersions{rows: arg})
}

// iteratorForRestoreValues implements pgx.CopyFromSource.
type iteratorForRestoreValues struct {
	rows                 []RestoreValuesParams
	skippedFirstNextCall bool
}

func (r *iteratorForRestoreValues) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForRestoreValues) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].CreatedAt,
		r.rows[0].UpdatedAt,
		r.rows[0].DeletedAt,
		r.rows[0].ProjectID,
		r.rows[0].KeyID,
		r.rows[0].LocaleID,
		r.rows[0].LocaleCode,
		r.rows[0].Value,
		r.rows[0].Status,
		r.rows[0].HasComments,
	}, nil
}

func (r iteratorForRestoreValues) Err() error {
	return nil
}

func (q *Queries) RestoreValues(ctx context.Context, arg []RestoreValuesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"value"}, []string{"id", "created_at", "updated_at", "deleted_at", "project_id", "key_id", "locale_id", "locale_code", "value", "status", "has_comments"}, &iteratorForRestoreValues{rows: arg})
}
